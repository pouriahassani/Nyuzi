import sys

#
# Generate all permuations of arithmetic instruction forms. I automate this
# because there are so many variations of vector/scalar/masked forms. This
# must be run manually when the instruction set changes.
#
# python make_operator_tests.py
#


def get_type_string(is_vector, is_float):
    if is_float:
        rettype = 'float'
    else:
        rettype = 'i32'

    if is_vector:
        rettype = '<16 x ' + rettype + '>'

    return rettype

BINARY_OPS = [
    ('or', 'or'),
    ('and', 'and'),
    ('xor', 'xor'),
    ('add', 'add_i'),
    ('sub', 'sub_i'),
    ('ashr', 'ashr'),
    ('lshr', 'shr'),
    ('shl', 'shl'),
    ('fadd', 'add_f'),
    ('fsub', 'sub_f'),
    ('fmul', 'mul_f')
]

REG_INSTRUCTION_TYPES = [
    ('s', 's', False),
    ('v', 's', False),
    ('v', 's', True),
    ('v', 'v', False),
    ('v', 'v', True)
]

IMM_INSTRUCTION_TYPES = [
    ('s', False),
    ('v', False),
    ('v', True),
]

op_test_fp = open('operator_tests.ll', 'w')
op_test_fp.write('''; RUN: llc -mtriple nyuzi-elf %s -o - | FileCheck %s
; This file is autogenerated by make_operator_tests.py. Do not edit.
;
; This test exhaustively validates arithmetic and compare instruction types,
; with all supported formats. The exception are scalar-only comparisons, which
; are in scalar_compare.ll because LLVM performs a lot of arbitrary transforms
; on them.

target triple = "nyuzi"
''')

########################################
# Arithmetic Tests
########################################

for llvmop, mnemonic in BINARY_OPS:
    is_float = mnemonic[-2:] == '_f'

    # Register operations
    for s1regt, s2regt, is_masked in REG_INSTRUCTION_TYPES:
        is_vector = s1regt == 'v'
        rettype = get_type_string(is_vector, is_float)
        funcname = 'test_' + llvmop + s1regt + \
            s2regt + ('m' if is_masked else '')
        op_test_fp.write('define ' + rettype + ' @' +
                         funcname + '(' + rettype + ' %a, ')
        op_test_fp.write(get_type_string(s2regt == 'v', is_float) + ' %b' +
                         (', <16 x i1> %mask' if is_masked else '') + ') { ; CHECK-LABEL: ' + funcname + ':\n')

        # Expand scalar to vector type
        if s1regt == 'v' and s2regt == 's':
            op_test_fp.write('  %single = insertelement ' + rettype + ' undef, ' +
                             get_type_string(s2regt == 'v', is_float) + ' %b, i32 0\n')
            op_test_fp.write('  %splat = shufflevector ' + rettype +
                             ' %single, ' + rettype + ' undef, <16 x i32> zeroinitializer\n')
            op_test_fp.write('  %1 = ' + llvmop + ' ' +
                             rettype + ' %a,%splat\n')
        else:
            op_test_fp.write('  %1 = ' + llvmop + ' ' + rettype + ' %a,%b\n')

        if is_masked:
            op_test_fp.write('  %2 = select <16 x i1> %mask, '
                             + rettype + ' %1, ' + rettype + ' %a\n')
            op_test_fp.write('  ; CHECK: ' + mnemonic + '_mask ' + s1regt +
                             '{{[0-9]+}}, s{{[0-9]+}}, ' + s1regt + '{{[0-9]+}}, ' + s2regt + '{{[0-9]+}}\n')
            op_test_fp.write('  ret ' + rettype + ' %2\n}\n\n')
        else:
            op_test_fp.write('  ; CHECK: ' + mnemonic + ' ' + s1regt +
                             '{{[0-9]+}}, ' + s1regt + '{{[0-9]+}}, ' + s2regt + '{{[0-9]+}}\n')
            op_test_fp.write('  ret ' + rettype + ' %1\n}\n\n')

    if is_float:
        continue  # Can't do immediate for FP instructions

    # Immediate operations
    for regt, is_masked in IMM_INSTRUCTION_TYPES:
        # XXXX Ugh. LLVM converts a scalar immediate subtract into a add with
        # a negative immediate. Skip this test. :(
        if mnemonic == 'sub_i' and regt == 's':
            continue

        rettype = get_type_string(regt == 'v', is_float)
        funcname = 'test_' + llvmop + regt + \
            'I' + ('m' if is_masked else '')
        op_test_fp.write('define ' + rettype + ' @' + funcname +
                         '(' + get_type_string(regt == 'v', is_float) + ' %a')
        if is_masked:
            op_test_fp.write(', <16 x i1> %mask) { ')
        else:
            op_test_fp.write(') { ')

        op_test_fp.write('; CHECK-LABEL: ' + funcname + ':\n')

        op_test_fp.write('  %1 = ' + llvmop + ' ' + rettype + ' %a, ')
        if regt == 'v':
            op_test_fp.write(
                '<i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27>\n')
        else:
            op_test_fp.write('27\n')

        if is_masked:
            op_test_fp.write('  %2 = select <16 x i1> %mask, ' + rettype
                             + ' %1, ' + rettype + ' %a\n')
            op_test_fp.write('  ; CHECK: ' + mnemonic + '_mask ' + regt +
                             '{{[0-9]+}}, s{{[0-9]+}}, ' + regt + '{{[0-9]+}}, ' + '27\n')
            op_test_fp.write('  ret ' + rettype + ' %2\n}\n\n')
        else:
            op_test_fp.write('  ; CHECK: ' + mnemonic + ' ' + regt +
                             '{{[0-9]+}}, ' + regt + '{{[0-9]+}}, ' + '27\n')
            op_test_fp.write('  ret ' + rettype + ' %1\n}\n\n')

########################################
# Vector Compare tests
########################################

COMPARE_TESTS = [
    ('icmp sgt', 'gt_i', False),
    ('icmp sge', 'ge_i', False),
    ('icmp slt', 'lt_i', False),
    ('icmp sle', 'le_i', False),
    ('icmp eq', 'eq_i', False),
    ('icmp ne', 'ne_i', False),
    ('icmp ugt', 'gt_u', False),
    ('icmp uge', 'ge_u', False),
    ('icmp ult', 'lt_u', False),
    ('icmp ule', 'le_u', False),
    ('fcmp ogt', 'gt_f', False),
    ('fcmp oge', 'ge_f', False),
    ('fcmp olt', 'lt_f', False),
    ('fcmp ole', 'le_f', False),
    ('fcmp ugt', 'le_f', True),
    ('fcmp uge', 'lt_f', True),
    ('fcmp ult', 'ge_f', True),
    ('fcmp ule', 'gt_f', True),
]

for llvminst, instr_suffix, must_invert in COMPARE_TESTS:
    # Vector op vector
    etype = 'float' if instr_suffix[-2:] == '_f' else 'i32'
    func_name = llvminst.replace(' ', '_')

    op_test_fp.write('define <16 x i1> @' + func_name + 'vv(<16 x ' + etype +
                     '> %a, <16 x ' + etype + '> %b) {	; CHECK-LABEL: ' + func_name + 'vv:\n')
    op_test_fp.write('  %c = ' + llvminst + ' <16 x ' + etype + '> %a, %b\n')
    op_test_fp.write('  ; CHECK: cmp' + instr_suffix +
                     ' s{{[0-9]+}}, v{{[0-9]+}}, v{{[0-9]+}}\n')
    if must_invert:
        op_test_fp.write('  ; CHECK: xor s{{[0-9]+}}, s{{[0-9]+}}\n')
    op_test_fp.write('  ret <16 x i1> %c\n')
    op_test_fp.write('}\n\n')

    # Vector op scalar
    op_test_fp.write('define <16 x i1> @' + func_name + 'vs(<16 x ' + etype +
                     '> %a, ' + etype + ' %b) {	; CHECK-LABEL: ' + func_name + 'vs:\n')
    op_test_fp.write('  %single = insertelement <16 x ' +
                     etype + '> undef, ' + etype + ' %b, i32 0\n')
    op_test_fp.write('  %splat = shufflevector <16 x ' + etype +
                     '> %single, <16 x ' + etype + '> undef, <16 x i32> zeroinitializer\n')

    op_test_fp.write('  %c = ' + llvminst + ' <16 x ' +
                     etype + '> %a, %splat\n')
    op_test_fp.write('  ; CHECK: cmp' + instr_suffix +
                     ' s{{[0-9]+}}, v{{[0-9]+}}, s{{[0-9]+}}\n')
    if must_invert:
        op_test_fp.write('  ; CHECK: xor s{{[0-9]+}}, s{{[0-9]+}}\n')

    op_test_fp.write('  ret <16 x i1> %c\n')
    op_test_fp.write('}\n\n')

    if instr_suffix[-2:] == '_f':
        continue

    # Vector op immediate
    op_test_fp.write('define <16 x i1> @' + func_name + 'vI(<16 x ' + etype +
                     '> %a, <16 x ' + etype + '> %b) {	; CHECK-LABEL: ' + func_name + 'vI:\n')
    op_test_fp.write('  %c = ' + llvminst + ' <16 x ' + etype +
                     '> %a, <i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27, i32 27>\n')
    op_test_fp.write('  ; CHECK: cmp' + instr_suffix +
                     ' s{{[0-9]+}}, v{{[0-9]+}}, 27\n')
    op_test_fp.write('  ret <16 x i1> %c\n')
    op_test_fp.write('}\n\n')
